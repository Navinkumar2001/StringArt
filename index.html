<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Art Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            height: calc(100vh - 40px);
        }
        .left-panel {
            flex: 0 0 450px;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            overflow-y: auto;
            max-height: 100%;
        }
        .right-panel {
            flex: 1;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: transparent;
            padding: 0;
            border-radius: 0;
            box-shadow: none;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
            grid-column: 1 / -1;
        }
        .input-section {
            margin-bottom: 15px;
        }
        .input-section h3 {
            margin-bottom: 10px;
            color: #495057;
        }
        textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }
        .go-to-line {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .go-to-line input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 100px;
        }
        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .thickness-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 10px 0;
            padding: 12px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .thickness-controls label {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }
        .thickness-controls input[type="range"] {
            width: 120px;
            margin: 0 8px;
        }
        .thickness-controls span {
            font-weight: bold;
            color: #667eea;
            min-width: 25px;
            font-size: 14px;
        }
        .feature-section {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #dee2e6;
        }
        .feature-section h3 {
            margin-top: 0;
            margin-bottom: 12px;
            color: #495057;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
            font-size: 16px;
        }
        .color-controls, .animation-controls, .export-controls, .zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin: 8px 0;
        }
        .color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
            margin-top: 5px;
        }
        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        .btn-preset {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 10px 15px;
            font-size: 14px;
        }
        .btn-export {
            background: linear-gradient(135deg, #fd7e14 0%, #e83e8c 100%);
            color: white;
        }
        .btn-animation {
            background: linear-gradient(135deg, #6f42c1 0%, #e83e8c 100%);
            color: white;
        }
        .btn-audio {
            background: linear-gradient(135deg, #17a2b8 0%, #6f42c1 100%);
            color: white;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
        button {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .info {
            display: flex;
            gap: 20px;
            margin: 0 0 15px 0;
            font-weight: bold;
            font-size: 16px;
            flex-wrap: wrap;
            justify-content: center;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }
        .canvas-container {
            text-align: center;
            margin: 0;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #fff;
            max-width: 100%;
            max-height: 70vh;
        }
        .current-sequence {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            margin: 0 0 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            text-align: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            font-weight: bold;
        }
        .go-to-line {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 10px 0;
        }
        .go-to-line input {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 80px;
        }
        
        /* Responsive design */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                height: auto;
            }
            .left-panel {
                flex: none;
                max-height: none;
            }
            .right-panel {
                flex: none;
                min-height: 500px;
            }
        }
        
        /* New feature styles */
        .advanced-controls, .effects-controls, .performance-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin: 8px 0;
        }
        .advanced-controls label, .effects-controls label, .performance-controls label {
            font-size: 12px;
            font-weight: 600;
        }
        .performance-controls select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="left-panel">
            <h1>String Art Visualizer</h1>
            
            <div class="input-section">
                <label for="pinSequence">Pin Sequence (comma-separated):</label>
                <textarea id="pinSequence" placeholder="Enter pin sequence: 0, 199, 97, 86, ..."></textarea>
            </div>
            
            <div class="input-section">
                <h3>Or Upload Image to Convert to String Art:</h3>
                <input type="file" id="imageUpload" accept="image/*">
                <div style="display: flex; gap: 10px; margin: 10px 0; align-items: center; flex-wrap: wrap;">
                    <label>Pins: <input type="number" id="numPins" value="200" min="50" max="500" style="width: 60px;"></label>
                    <label>Lines: <input type="number" id="numLines" value="3500" min="100" max="10000" style="width: 60px;"></label>
                    <label>Thickness: <input type="number" id="lineThickness" value="1" min="0.1" max="5" step="0.1" style="width: 60px;"></label>
                    <button class="btn-primary" onclick="convertImage()">Convert</button>
                </div>
            </div>
            
            <div class="go-to-line">
                <label for="gotoLine">Go to Line:</label>
                <input type="number" id="gotoLine" min="1" placeholder="Line #">
                <button class="btn-secondary" onclick="goToLine()">Go</button>
            </div>
            
            <div class="controls">
                <button class="btn-primary" onclick="loadSequence()">Load Sequence</button>
                <button class="btn-secondary" onclick="previousPin()">‚Üê Previous</button>
                <button class="btn-secondary" onclick="nextPin()">Next ‚Üí</button>
                <button class="btn-primary" onclick="simulateStepWithAudio()">Simulate Step</button>
                <button class="btn-primary" onclick="generateArt()">Generate Full Art</button>
            </div>
            
            <div class="thickness-controls">
                <label for="mainThickness">Line Thickness: </label>
                <input type="range" id="mainThickness" min="0.5" max="5" step="0.1" value="1.5">
                <span id="thicknessValue">1.5</span>px
                <button class="btn-secondary" onclick="updateThickness()">Apply</button>
            </div>

            <div class="feature-section">
                <h3>üé® Color & Style</h3>
                <div class="color-controls">
                    <label>Line Color:</label>
                    <input type="color" id="lineColor" class="color-picker" value="#000000">
                    <label>Background:</label>
                    <input type="color" id="bgColor" class="color-picker" value="#ffffff">
                    <label>Pin Color:</label>
                    <input type="color" id="pinColor" class="color-picker" value="#666666">
                    <button class="btn-secondary" onclick="applyColors()">Apply Colors</button>
                    <button class="btn-secondary" onclick="resetColors()">Reset</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üé¨ Animation Controls</h3>
                <div class="animation-controls">
                    <button class="btn-animation" onclick="toggleAutoPlay()" id="autoPlayBtn">‚ñ∂Ô∏è Auto Play</button>
                    <label>Speed:</label>
                    <input type="range" id="animSpeed" min="50" max="5000" value="500" style="width: 120px;">
                    <span id="speedValue">500</span>ms
                    <button class="btn-secondary" onclick="resetAnimation()">Reset</button>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>

            <div class="feature-section">
                <h3>üîä Audio Controls</h3>
                <div class="animation-controls">
                    <button class="btn-audio" onclick="toggleAudio()" id="audioBtn">üîä Enable Audio</button>
                    <label>Volume:</label>
                    <input type="range" id="audioVolume" min="0" max="100" value="50" style="width: 100px;">
                    <span id="volumeValue">50</span>%
                    <label>Pitch:</label>
                    <select id="audioPitch">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                        <option value="distance">Distance-based</option>
                    </select>
                </div>
                <div class="animation-controls">
                    <label>Sound Type:</label>
                    <select id="soundType">
                        <option value="beep" selected>Beep</option>
                        <option value="click">Click</option>
                        <option value="pluck">Pluck</option>
                        <option value="chord">Chord</option>
                    </select>
                    <button class="btn-audio" onclick="testAudio()">ÔøΩ Test Soundo</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üó£Ô∏è Speech Controls</h3>
                <div class="animation-controls">
                    <button class="btn-audio" onclick="toggleSpeech()" id="speechBtn">üó£Ô∏è Enable Speech</button>
                    <label>Speech Rate:</label>
                    <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="1" style="width: 100px;">
                    <span id="rateValue">1</span>x
                    <button class="btn-audio" onclick="testSpeech()">üé§ Test Speech</button>
                </div>
                <div class="animation-controls">
                    <label>Speech Delay:</label>
                    <input type="range" id="speechDelay" min="0" max="5000" step="100" value="200" style="width: 120px;">
                    <span id="delayValue">200</span>ms
                    <label>Mode:</label>
                    <select id="speechMode">
                        <option value="immediate">Immediate</option>
                        <option value="delayed" selected>Delayed</option>
                        <option value="sequence">Sequence Only</option>
                    </select>
                    <button class="btn-audio" onclick="speakSequence()">üì¢ Speak All</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üíæ Export & Save</h3>
                <div class="export-controls">
                    <button class="btn-export" onclick="downloadImage()">ÔøΩ Save as ePNG</button>
                    <button class="btn-export" onclick="downloadSequence()">ÔøΩ  Save Sequence</button>
                    <button class="btn-secondary" onclick="copySequence()">üìã Copy to Clipboard</button>
                    <input type="file" id="sequenceUpload" accept=".txt,.json" style="display: none;">
                    <button class="btn-secondary" onclick="document.getElementById('sequenceUpload').click()">üìÅ Load Sequence File</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üéØ Preset Patterns</h3>
                <div class="preset-buttons">
                    <button class="btn-preset" onclick="loadPreset('spiral')">üåÄ Spiral</button>
                    <button class="btn-preset" onclick="loadPreset('star')">‚≠ê Star</button>
                    <button class="btn-preset" onclick="loadPreset('flower')">üå∏ Flower</button>
                    <button class="btn-preset" onclick="loadPreset('mandala')">üï∏Ô∏è Mandala</button>
                    <button class="btn-preset" onclick="loadPreset('random')">üé≤ Random</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üîß Advanced Features</h3>
                <div class="advanced-controls">
                    <button class="btn-secondary" onclick="togglePinNumbers()">üî¢ Toggle Pin Numbers</button>
                    <button class="btn-secondary" onclick="toggleGrid()">üìê Toggle Grid</button>
                    <button class="btn-secondary" onclick="mirrorPattern()">ü™û Mirror Pattern</button>
                    <button class="btn-secondary" onclick="reversePattern()">‚Ü©Ô∏è Reverse Pattern</button>
                </div>
                <div class="zoom-controls">
                    <label>Zoom:</label>
                    <button class="btn-secondary" onclick="zoomIn()">üîç+</button>
                    <button class="btn-secondary" onclick="zoomOut()">üîç-</button>
                    <button class="btn-secondary" onclick="resetZoom()">üéØ Reset</button>
                    <label>Pan Mode:</label>
                    <button class="btn-secondary" onclick="togglePanMode()" id="panBtn">‚úã Pan</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üé® Visual Effects</h3>
                <div class="effects-controls">
                    <label>Opacity:</label>
                    <input type="range" id="lineOpacity" min="0.1" max="1" step="0.1" value="0.8" style="width: 100px;">
                    <span id="opacityValue">0.8</span>
                    <label>Glow Effect:</label>
                    <input type="checkbox" id="glowEffect" onchange="toggleGlow()">
                    <label>Rainbow Mode:</label>
                    <input type="checkbox" id="rainbowMode" onchange="toggleRainbow()">
                </div>
            </div>

            <div class="feature-section">
                <h3>‚ö° Performance</h3>
                <div class="performance-controls">
                    <label>Render Quality:</label>
                    <select id="renderQuality" onchange="updateRenderQuality()">
                        <option value="high">High Quality</option>
                        <option value="medium" selected>Medium Quality</option>
                        <option value="low">Fast Rendering</option>
                    </select>
                    <button class="btn-secondary" onclick="optimizeSequence()">‚ö° Optimize Sequence</button>
                </div>
            </div>

            <div class="feature-section">
                <h3>üìä Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalLength">0</div>
                        <div class="stat-label">Total Length (px)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgDistance">0</div>
                        <div class="stat-label">Avg Distance</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="complexity">0</div>
                        <div class="stat-label">Complexity Score</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="coverage">0%</div>
                        <div class="stat-label">Pin Coverage</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="info">
                <div>Current Position: <span id="currentPos">0</span></div>
                <div>Total Pins: <span id="totalPins">0</span></div>
                <div>Lines Count: <span id="linesCount">0</span></div>
            </div>
            
            <div class="current-sequence">
                Current: <span id="currentSequence">-</span>
            </div>
            
            <div class="canvas-container">
                <canvas id="artCanvas" width="800" height="800"></canvas>
            </div>
        </div>
    </div>

    <script>
        let pinSequence = [];
        let currentIndex = 0;
        let totalPinsInCircle = 200;
        let currentThickness = 1.5;
        let isAutoPlaying = false;
        let autoPlayInterval = null;
        let currentColors = {
            line: '#000000',
            background: '#ffffff',
            pin: '#666666'
        };
        
        // Audio variables
        let audioContext = null;
        let audioEnabled = false;
        let audioVolume = 0.5;
        let audioPitch = 'medium';
        let soundType = 'beep';
        
        // Speech variables
        let speechEnabled = false;
        let speechRate = 1;
        let speechSynth = null;
        let speechDelay = 200;
        let speechMode = 'delayed';
        let speechTimeout = null;
        
        // New feature variables
        let showPinNumbers = false;
        let showGrid = false;
        let glowEffect = false;
        let rainbowMode = false;
        let currentZoom = 1;
        let panMode = false;
        let panOffset = { x: 0, y: 0 };
        let renderQuality = 'medium';
        let lineOpacity = 0.8;
        
        // Performance optimization
        let renderCache = new Map();
        let lastRenderTime = 0;
        const RENDER_THROTTLE = 16; // ~60fps
        
        // Update thickness display when slider changes
        document.addEventListener('DOMContentLoaded', function() {
            const thicknessSlider = document.getElementById('mainThickness');
            const thicknessValue = document.getElementById('thicknessValue');
            const speedSlider = document.getElementById('animSpeed');
            const speedValue = document.getElementById('speedValue');
            const sequenceUpload = document.getElementById('sequenceUpload');
            const opacitySlider = document.getElementById('lineOpacity');
            const opacityValue = document.getElementById('opacityValue');
            const volumeSlider = document.getElementById('audioVolume');
            const volumeValue = document.getElementById('volumeValue');
            
            thicknessSlider.addEventListener('input', function() {
                thicknessValue.textContent = this.value;
            });
            
            speedSlider.addEventListener('input', function() {
                speedValue.textContent = this.value;
            });
            
            opacitySlider.addEventListener('input', function() {
                opacityValue.textContent = this.value;
                lineOpacity = parseFloat(this.value);
                throttledRender();
            });
            
            volumeSlider.addEventListener('input', function() {
                volumeValue.textContent = this.value;
                audioVolume = parseFloat(this.value) / 100;
            });
            
            const speechRateSlider = document.getElementById('speechRate');
            const rateValue = document.getElementById('rateValue');
            
            speechRateSlider.addEventListener('input', function() {
                rateValue.textContent = this.value;
                speechRate = parseFloat(this.value);
            });
            
            const speechDelaySlider = document.getElementById('speechDelay');
            const delayValue = document.getElementById('delayValue');
            
            speechDelaySlider.addEventListener('input', function() {
                delayValue.textContent = this.value;
                speechDelay = parseInt(this.value);
            });
            
            document.getElementById('speechMode').addEventListener('change', function() {
                speechMode = this.value;
            });
            
            // Audio control event listeners
            document.getElementById('audioPitch').addEventListener('change', updateAudioSettings);
            document.getElementById('soundType').addEventListener('change', updateAudioSettings);
            
            sequenceUpload.addEventListener('change', handleSequenceUpload);
            
            // Auto-apply thickness on slider release
            thicknessSlider.addEventListener('change', function() {
                updateThickness();
            });
            
            // Apply thickness on Enter key
            thicknessSlider.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    updateThickness();
                }
            });
            
            // Add canvas event listeners for pan and zoom (simplified)
            const canvas = document.getElementById('artCanvas');
            if (canvas) {
                canvas.addEventListener('wheel', handleZoom);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);
            }
            
            // Initialize audio context on first user interaction
            document.addEventListener('click', initAudioContext, { once: true });
            
            // Initialize speech synthesis
            if ('speechSynthesis' in window) {
                speechSynth = window.speechSynthesis;
            }
        });
        
        // Audio Functions
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function toggleAudio() {
            audioEnabled = !audioEnabled;
            const btn = document.getElementById('audioBtn');
            btn.textContent = audioEnabled ? 'üîá Disable Audio' : 'üîä Enable Audio';
            
            if (audioEnabled) {
                initAudioContext();
            }
        }

        function testAudio() {
            if (!audioEnabled) {
                alert('Please enable audio first');
                return;
            }
            playSound(100, 0.2); // Test sound
        }

        function playSound(pin, duration = 0.1) {
            if (!audioEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Calculate frequency based on pin and settings
            let frequency = getFrequencyForPin(pin);
            
            // Set sound type
            switch(soundType) {
                case 'beep':
                    oscillator.type = 'sine';
                    break;
                case 'click':
                    oscillator.type = 'square';
                    duration = 0.05;
                    break;
                case 'pluck':
                    oscillator.type = 'sawtooth';
                    break;
                case 'chord':
                    // Play a chord (root + fifth)
                    playChord(frequency, duration);
                    return;
            }
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            // Set volume with envelope
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(audioVolume * 0.3, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playChord(rootFreq, duration) {
            // Play root note
            playTone(rootFreq, duration, 'sine');
            // Play fifth (1.5x frequency)
            playTone(rootFreq * 1.5, duration, 'sine');
            // Play octave (2x frequency) at lower volume
            playTone(rootFreq * 2, duration, 'sine', 0.5);
        }

        function playTone(frequency, duration, type = 'sine', volumeMultiplier = 1) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(audioVolume * 0.2 * volumeMultiplier, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function getFrequencyForPin(pin) {
            let baseFreq;
            
            switch(audioPitch) {
                case 'low':
                    baseFreq = 200;
                    break;
                case 'medium':
                    baseFreq = 400;
                    break;
                case 'high':
                    baseFreq = 800;
                    break;
                case 'distance':
                    // Base frequency on distance from previous pin
                    if (currentIndex > 0) {
                        const prevPin = pinSequence[currentIndex - 1];
                        const distance = calculatePinDistance(prevPin, pin);
                        baseFreq = 200 + (distance / 800) * 600; // Scale distance to frequency
                    } else {
                        baseFreq = 400;
                    }
                    break;
                default:
                    baseFreq = 400;
            }
            
            // Map pin number to musical scale
            const scaleNotes = [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8]; // Major scale ratios
            const noteIndex = pin % scaleNotes.length;
            const octave = Math.floor(pin / scaleNotes.length) % 3;
            
            return baseFreq * scaleNotes[noteIndex] * Math.pow(2, octave * 0.5);
        }

        function updateAudioSettings() {
            audioPitch = document.getElementById('audioPitch').value;
            soundType = document.getElementById('soundType').value;
        }

        // Speech Functions
        function initSpeechSynth() {
            if ('speechSynthesis' in window) {
                speechSynth = window.speechSynthesis;
                return true;
            } else {
                alert('Speech synthesis not supported in this browser');
                return false;
            }
        }

        function toggleSpeech() {
            speechEnabled = !speechEnabled;
            const btn = document.getElementById('speechBtn');
            btn.textContent = speechEnabled ? 'üîá Disable Speech' : 'üó£Ô∏è Enable Speech';
            
            if (speechEnabled && !speechSynth) {
                initSpeechSynth();
            }
        }

        function testSpeech() {
            if (!speechEnabled) {
                alert('Please enable speech first');
                return;
            }
            speakNumber(42); // Test with pin number 42
        }

        function speakNumber(numberToSpeak) {
            if (!speechEnabled) return;
            
            // Clear any existing speech timeout
            if (speechTimeout) {
                clearTimeout(speechTimeout);
                speechTimeout = null;
            }
            
            const speakNow = () => {
                if ('speechSynthesis' in window) {
                    const synth = window.speechSynthesis;
                    
                    // Cancel any ongoing speech to prevent overlap
                    synth.cancel();
                    
                    // The browser will read the number as one continuous value (e.g., "twelve thousand three hundred forty-five")
                    // For individual digits, you would need to format the input string with spaces (e.g., "1 2 3 4 5")
                    const utterance = new SpeechSynthesisUtterance(numberToSpeak.toString());
                    
                    // Customize properties
                    utterance.lang = 'en-US'; // Set language
                    utterance.rate = speechRate; // Use the rate from slider
                    utterance.pitch = 1; // Set pitch (0 to 2)
                    utterance.volume = audioVolume; // Use the same volume as audio
                    
                    synth.speak(utterance);
                } else {
                    console.error('Text-to-speech not supported in this browser.');
                }
            };
            
            // Handle different speech modes
            switch(speechMode) {
                case 'immediate':
                    speakNow();
                    break;
                case 'delayed':
                    speechTimeout = setTimeout(speakNow, speechDelay);
                    break;
                case 'sequence':
                    // Only speak during auto-play sequence
                    if (isAutoPlaying) {
                        speechTimeout = setTimeout(speakNow, speechDelay);
                    }
                    break;
            }
        }

        function speakSequence() {
            if (!speechEnabled || pinSequence.length === 0) {
                alert('Please enable speech and load a sequence first');
                return;
            }
            
            let index = 0;
            const speakNext = () => {
                if (index < pinSequence.length) {
                    speakNumber(pinSequence[index]);
                    index++;
                    
                    // Calculate delay based on speech rate and additional delay
                    const baseDelay = 1000 / speechRate; // Base delay inversely related to speech rate
                    const totalDelay = baseDelay + speechDelay;
                    
                    setTimeout(speakNext, totalDelay);
                }
            };
            
            speakNext();
        }

        // Performance optimization - throttled rendering
        function throttledRender() {
            const now = Date.now();
            if (now - lastRenderTime > RENDER_THROTTLE) {
                if (pinSequence.length > 0) {
                    simulateStep();
                }
                lastRenderTime = now;
            }
        }
        
        function updateThickness() {
            const thickness = parseFloat(document.getElementById('mainThickness').value);
            currentThickness = thickness;
            
            // Redraw current view with new thickness
            if (pinSequence.length > 0) {
                simulateStep();
            }
        }

        // Color and Style Functions
        function applyColors() {
            currentColors.line = document.getElementById('lineColor').value;
            currentColors.background = document.getElementById('bgColor').value;
            currentColors.pin = document.getElementById('pinColor').value;
            
            if (pinSequence.length > 0) {
                simulateStep();
            }
        }

        function resetColors() {
            currentColors = { line: '#000000', background: '#ffffff', pin: '#666666' };
            document.getElementById('lineColor').value = currentColors.line;
            document.getElementById('bgColor').value = currentColors.background;
            document.getElementById('pinColor').value = currentColors.pin;
            applyColors();
        }

        // Animation Functions
        function toggleAutoPlay() {
            const btn = document.getElementById('autoPlayBtn');
            if (isAutoPlaying) {
                stopAutoPlay();
                btn.textContent = '‚ñ∂Ô∏è Auto Play';
            } else {
                startAutoPlay();
                btn.textContent = '‚è∏Ô∏è Pause';
            }
        }

        function startAutoPlay() {
            if (pinSequence.length === 0) {
                alert('Please load a sequence first');
                return;
            }
            
            isAutoPlaying = true;
            const speed = parseInt(document.getElementById('animSpeed').value);
            
            autoPlayInterval = setInterval(() => {
                currentIndex = (currentIndex + 1) % pinSequence.length;
                updateDisplay();
                simulateStep();
                updateProgress();
                
                // Play audio for the current pin during auto-play
                if (audioEnabled && currentIndex < pinSequence.length) {
                    const currentPin = pinSequence[currentIndex];
                    playSound(currentPin);
                }
                
                // Speak the pin number during auto-play
                if (speechEnabled && currentIndex < pinSequence.length) {
                    const currentPin = pinSequence[currentIndex];
                    speakNumber(currentPin);
                }
                
                if (currentIndex >= pinSequence.length - 1) {
                    stopAutoPlay();
                    document.getElementById('autoPlayBtn').textContent = '‚ñ∂Ô∏è Auto Play';
                }
            }, speed);
        }

        function stopAutoPlay() {
            isAutoPlaying = false;
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            // Clear any pending speech
            if (speechTimeout) {
                clearTimeout(speechTimeout);
                speechTimeout = null;
            }
            
            // Stop any ongoing speech
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
            }
        }

        function resetAnimation() {
            stopAutoPlay();
            currentIndex = 0;
            updateDisplay();
            updateProgress();
            simulateStep();
            document.getElementById('autoPlayBtn').textContent = '‚ñ∂Ô∏è Auto Play';
        }

        function updateProgress() {
            if (pinSequence.length > 0) {
                const progress = (currentIndex / (pinSequence.length - 1)) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
            }
        }

        // Export Functions
        function downloadImage() {
            const canvas = document.getElementById('artCanvas');
            const link = document.createElement('a');
            link.download = 'string-art.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function downloadSequence() {
            if (pinSequence.length === 0) {
                alert('No sequence to download');
                return;
            }
            
            const data = {
                sequence: pinSequence,
                totalPins: totalPinsInCircle,
                thickness: currentThickness,
                colors: currentColors,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'string-art-sequence.json';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function copySequence() {
            if (pinSequence.length === 0) {
                alert('No sequence to copy');
                return;
            }
            
            navigator.clipboard.writeText(pinSequence.join(', ')).then(() => {
                alert('Sequence copied to clipboard!');
            });
        }

        function handleSequenceUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.sequence && Array.isArray(data.sequence)) {
                        pinSequence = data.sequence;
                        totalPinsInCircle = data.totalPins || 200;
                        currentThickness = data.thickness || 1.5;
                        
                        if (data.colors) {
                            currentColors = data.colors;
                            document.getElementById('lineColor').value = currentColors.line;
                            document.getElementById('bgColor').value = currentColors.background;
                            document.getElementById('pinColor').value = currentColors.pin;
                        }
                        
                        document.getElementById('pinSequence').value = pinSequence.join(', ');
                        document.getElementById('mainThickness').value = currentThickness;
                        document.getElementById('thicknessValue').textContent = currentThickness;
                        
                        currentIndex = 0;
                        updateDisplay();
                        calculateStatistics();
                        simulateStep();
                        
                        alert('Sequence loaded successfully!');
                    }
                } catch (error) {
                    alert('Invalid file format');
                }
            };
            reader.readAsText(file);
        }

        // Preset Patterns
        function loadPreset(type) {
            let sequence = [];
            const pins = 200;
            
            switch(type) {
                case 'spiral':
                    sequence = generateSpiral(pins);
                    break;
                case 'star':
                    sequence = generateStar(pins);
                    break;
                case 'flower':
                    sequence = generateFlower(pins);
                    break;
                case 'mandala':
                    sequence = generateMandala(pins);
                    break;
                case 'random':
                    sequence = generateRandom(pins, 1000);
                    break;
            }
            
            pinSequence = sequence;
            totalPinsInCircle = pins;
            currentIndex = 0;
            
            document.getElementById('pinSequence').value = sequence.join(', ');
            document.getElementById('totalPins').textContent = sequence.length;
            updateDisplay();
            calculateStatistics();
            simulateStep();
        }

        function generateSpiral(pins) {
            const sequence = [];
            let current = 0;
            const step = Math.floor(pins / 8);
            
            for (let i = 0; i < pins * 2; i++) {
                sequence.push(current);
                current = (current + step) % pins;
                if (i % 50 === 0) step += 1;
            }
            return sequence;
        }

        function generateStar(pins) {
            const sequence = [];
            const points = 5;
            const step = Math.floor(pins / points);
            
            for (let i = 0; i < points * 20; i++) {
                const point = i % points;
                const pin = (point * step + Math.floor(i / points) * 3) % pins;
                sequence.push(pin);
            }
            return sequence;
        }

        function generateFlower(pins) {
            const sequence = [];
            const petals = 8;
            const step = Math.floor(pins / petals);
            
            for (let i = 0; i < petals * 15; i++) {
                const petal = i % petals;
                const offset = Math.sin(i * 0.1) * 10;
                const pin = Math.floor((petal * step + offset) % pins);
                sequence.push(pin);
            }
            return sequence;
        }

        function generateMandala(pins) {
            const sequence = [];
            const layers = 6;
            
            for (let layer = 0; layer < layers; layer++) {
                const step = Math.floor(pins / (layer + 3));
                for (let i = 0; i < pins / 2; i++) {
                    const pin = (i * step + layer * 5) % pins;
                    sequence.push(pin);
                }
            }
            return sequence;
        }

        function generateRandom(pins, count) {
            const sequence = [];
            for (let i = 0; i < count; i++) {
                sequence.push(Math.floor(Math.random() * pins));
            }
            return sequence;
        }

        // Statistics Functions
        function calculateStatistics() {
            if (pinSequence.length === 0) return;
            
            let totalLength = 0;
            let distances = [];
            const usedPins = new Set();
            
            for (let i = 0; i < pinSequence.length - 1; i++) {
                const pin1 = pinSequence[i];
                const pin2 = pinSequence[i + 1];
                
                usedPins.add(pin1);
                usedPins.add(pin2);
                
                const distance = calculatePinDistance(pin1, pin2);
                distances.push(distance);
                totalLength += distance;
            }
            
            const avgDistance = distances.length > 0 ? totalLength / distances.length : 0;
            const complexity = calculateComplexity(distances);
            const coverage = (usedPins.size / totalPinsInCircle) * 100;
            
            document.getElementById('totalLength').textContent = Math.round(totalLength);
            document.getElementById('avgDistance').textContent = Math.round(avgDistance);
            document.getElementById('complexity').textContent = Math.round(complexity);
            document.getElementById('coverage').textContent = Math.round(coverage) + '%';
        }

        function calculatePinDistance(pin1, pin2) {
            const angle1 = (pin1 / totalPinsInCircle) * 2 * Math.PI;
            const angle2 = (pin2 / totalPinsInCircle) * 2 * Math.PI;
            const radius = 380;
            
            const x1 = radius * Math.cos(angle1);
            const y1 = radius * Math.sin(angle1);
            const x2 = radius * Math.cos(angle2);
            const y2 = radius * Math.sin(angle2);
            
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function calculateComplexity(distances) {
            if (distances.length === 0) return 0;
            
            const mean = distances.reduce((a, b) => a + b, 0) / distances.length;
            const variance = distances.reduce((a, b) => a + (b - mean) ** 2, 0) / distances.length;
            return Math.sqrt(variance);
        }

        // Advanced Features
        function togglePinNumbers() {
            showPinNumbers = !showPinNumbers;
            throttledRender();
        }

        function toggleGrid() {
            showGrid = !showGrid;
            throttledRender();
        }

        function mirrorPattern() {
            if (pinSequence.length === 0) {
                alert('Please load a sequence first');
                return;
            }
            
            const mirrored = pinSequence.map(pin => (totalPinsInCircle - pin) % totalPinsInCircle);
            pinSequence = [...pinSequence, ...mirrored];
            
            document.getElementById('pinSequence').value = pinSequence.join(', ');
            document.getElementById('totalPins').textContent = pinSequence.length;
            calculateStatistics();
            throttledRender();
        }

        function reversePattern() {
            if (pinSequence.length === 0) {
                alert('Please load a sequence first');
                return;
            }
            
            pinSequence.reverse();
            document.getElementById('pinSequence').value = pinSequence.join(', ');
            throttledRender();
        }

        // Visual Effects
        function toggleGlow() {
            glowEffect = document.getElementById('glowEffect').checked;
            throttledRender();
        }

        function toggleRainbow() {
            rainbowMode = document.getElementById('rainbowMode').checked;
            throttledRender();
        }

        // Zoom and Pan Functions
        function zoomIn() {
            currentZoom = Math.min(currentZoom * 1.2, 5);
            throttledRender();
        }

        function zoomOut() {
            currentZoom = Math.max(currentZoom / 1.2, 0.2);
            throttledRender();
        }

        function resetZoom() {
            currentZoom = 1;
            panOffset = { x: 0, y: 0 };
            throttledRender();
        }

        function togglePanMode() {
            panMode = !panMode;
            const btn = document.getElementById('panBtn');
            btn.textContent = panMode ? 'üîí Lock' : '‚úã Pan';
            document.getElementById('artCanvas').style.cursor = panMode ? 'grab' : 'default';
        }

        // Mouse event handlers for pan and zoom
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };

        function handleZoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            currentZoom = Math.max(0.2, Math.min(5, currentZoom * delta));
            throttledRender();
        }

        function handleMouseDown(e) {
            if (panMode) {
                isDragging = true;
                lastMousePos = { x: e.clientX, y: e.clientY };
                document.getElementById('artCanvas').style.cursor = 'grabbing';
            }
        }

        function handleMouseMove(e) {
            if (isDragging && panMode) {
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                panOffset.x += deltaX;
                panOffset.y += deltaY;
                lastMousePos = { x: e.clientX, y: e.clientY };
                throttledRender();
            }
        }

        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                document.getElementById('artCanvas').style.cursor = panMode ? 'grab' : 'default';
            }
        }

        // Performance Functions
        function updateRenderQuality() {
            renderQuality = document.getElementById('renderQuality').value;
            renderCache.clear(); // Clear cache when quality changes
            throttledRender();
        }

        function optimizeSequence() {
            if (pinSequence.length === 0) {
                alert('Please load a sequence first');
                return;
            }
            
            // Remove consecutive duplicate pins
            const optimized = [];
            for (let i = 0; i < pinSequence.length; i++) {
                if (i === 0 || pinSequence[i] !== pinSequence[i - 1]) {
                    optimized.push(pinSequence[i]);
                }
            }
            
            // Remove very short segments (less than 5 pixels)
            const filtered = [optimized[0]];
            for (let i = 1; i < optimized.length; i++) {
                const distance = calculatePinDistance(optimized[i - 1], optimized[i]);
                if (distance > 5) {
                    filtered.push(optimized[i]);
                }
            }
            
            pinSequence = filtered;
            document.getElementById('pinSequence').value = pinSequence.join(', ');
            document.getElementById('totalPins').textContent = pinSequence.length;
            calculateStatistics();
            throttledRender();
            
            alert(`Optimized sequence: ${optimized.length - filtered.length} redundant points removed`);
        }

        // Enhanced rendering function with new features
        function getLineColor(index) {
            if (rainbowMode) {
                const hue = (index / pinSequence.length) * 360;
                return `hsl(${hue}, 70%, 50%)`;
            }
            return currentColors.line;
        }
        
        function loadSequence() {
            const input = document.getElementById('pinSequence').value;
            if (!input.trim()) {
                alert('Please enter a pin sequence');
                return;
            }
            
            pinSequence = input.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));
            currentIndex = 0;
            
            document.getElementById('totalPins').textContent = pinSequence.length;
            document.getElementById('gotoLine').max = pinSequence.length;
            updateDisplay();
            calculateStatistics();
            simulateStep();
        }
        
        function previousPin() {
            if (pinSequence.length === 0) return;
            currentIndex = (currentIndex - 1 + pinSequence.length) % pinSequence.length;
            updateDisplay();
            simulateStep();
        }
        
        function nextPin() {
            if (pinSequence.length === 0) return;
            currentIndex = (currentIndex + 1) % pinSequence.length;
            updateDisplay();
            simulateStep();
            
            // Play audio for the current pin
            if (audioEnabled && currentIndex < pinSequence.length) {
                const currentPin = pinSequence[currentIndex];
                playSound(currentPin);
            }
            
            // Speak the pin number
            if (speechEnabled && currentIndex < pinSequence.length) {
                const currentPin = pinSequence[currentIndex];
                speakNumber(currentPin);
            }
        }
        
        function updateDisplay() {
            document.getElementById('currentPos').textContent = currentIndex + 1;
            document.getElementById('linesCount').textContent = Math.max(0, currentIndex);
            
            if (pinSequence.length > 0) {
                const current = pinSequence[currentIndex];
                const prev = currentIndex > 0 ? pinSequence[currentIndex - 1] : '-';
                const next = currentIndex < pinSequence.length - 1 ? pinSequence[currentIndex + 1] : '-';
                document.getElementById('currentSequence').textContent = `${prev} ‚Üí ${current} ‚Üí ${next}`;
                
                highlightCurrentPin();
                updateProgress();
            }
        }
        
        function highlightCurrentPin() {
            const textarea = document.getElementById('pinSequence');
            const text = textarea.value;
            const pins = text.split(',');
            
            let startPos = 0;
            for (let i = 0; i < currentIndex && i < pins.length; i++) {
                startPos += pins[i].length + 1;
            }
            
            if (currentIndex < pins.length) {
                const endPos = startPos + pins[currentIndex].length;
                
                textarea.focus();
                textarea.setSelectionRange(startPos, endPos);
                
                const lineHeight = 20;
                const lines = text.substring(0, startPos).split('\n').length;
                textarea.scrollTop = Math.max(0, (lines - 3) * lineHeight);
            }
        }
        
        function goToLine() {
            const lineNum = parseInt(document.getElementById('gotoLine').value);
            if (isNaN(lineNum) || lineNum < 1 || lineNum > pinSequence.length) {
                alert(`Please enter a valid line number (1-${pinSequence.length})`);
                return;
            }
            
            currentIndex = lineNum - 1;
            updateDisplay();
            simulateStep();
        }
        
        function simulateStepWithAudio() {
            simulateStep();
            
            // Play audio for the current pin
            if (audioEnabled && currentIndex < pinSequence.length) {
                const currentPin = pinSequence[currentIndex];
                playSound(currentPin);
            }
            
            // Speak the pin number
            if (speechEnabled && currentIndex < pinSequence.length) {
                const currentPin = pinSequence[currentIndex];
                speakNumber(currentPin);
            }
        }

        function simulateStep() {
            if (pinSequence.length === 0) {
                alert('Please load a pin sequence first');
                return;
            }
            
            const canvas = document.getElementById('artCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 380;
            
            // Clear and set background
            ctx.fillStyle = currentColors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid if enabled
            if (showGrid) {
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.3;
                
                // Radial lines
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * 2 * Math.PI;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
                    ctx.stroke();
                }
                
                // Concentric circles
                for (let r = radius / 4; r <= radius; r += radius / 4) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
            
            // Draw pins
            ctx.fillStyle = currentColors.pin;
            for (let i = 0; i < totalPinsInCircle; i++) {
                const angle = (i / totalPinsInCircle) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Draw lines
            ctx.lineWidth = currentThickness;
            ctx.globalAlpha = lineOpacity;
            
            if (glowEffect) {
                ctx.shadowColor = currentColors.line;
                ctx.shadowBlur = 5;
            }
            
            for (let i = 0; i < currentIndex && i < pinSequence.length - 1; i++) {
                const pin1 = pinSequence[i];
                const pin2 = pinSequence[i + 1];
                
                const angle1 = (pin1 / totalPinsInCircle) * 2 * Math.PI;
                const angle2 = (pin2 / totalPinsInCircle) * 2 * Math.PI;
                
                const x1 = centerX + radius * Math.cos(angle1);
                const y1 = centerY + radius * Math.sin(angle1);
                const x2 = centerX + radius * Math.cos(angle2);
                const y2 = centerY + radius * Math.sin(angle2);
                
                ctx.strokeStyle = rainbowMode ? getLineColor(i) : currentColors.line;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Draw current line highlight
            if (currentIndex < pinSequence.length - 1) {
                const pin1 = pinSequence[currentIndex];
                const pin2 = pinSequence[currentIndex + 1];
                
                const angle1 = (pin1 / totalPinsInCircle) * 2 * Math.PI;
                const angle2 = (pin2 / totalPinsInCircle) * 2 * Math.PI;
                
                const x1 = centerX + radius * Math.cos(angle1);
                const y1 = centerY + radius * Math.sin(angle1);
                const x2 = centerX + radius * Math.cos(angle2);
                const y2 = centerY + radius * Math.sin(angle2);
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = Math.max(3, currentThickness + 1);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Draw current pin highlight
            if (currentIndex < pinSequence.length) {
                const currentPin = pinSequence[currentIndex];
                const angle = (currentPin / totalPinsInCircle) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Draw pin numbers if enabled
            if (showPinNumbers) {
                ctx.fillStyle = '#333';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                
                const step = Math.max(1, Math.floor(totalPinsInCircle / 50));
                
                for (let i = 0; i < totalPinsInCircle; i += step) {
                    const angle = (i / totalPinsInCircle) * 2 * Math.PI;
                    const x = centerX + (radius + 15) * Math.cos(angle);
                    const y = centerY + (radius + 15) * Math.sin(angle);
                    
                    ctx.fillText(i.toString(), x, y);
                }
            }
        }
        
        function generateArt() {
            if (pinSequence.length === 0) {
                alert('Please load a pin sequence first');
                return;
            }
            
            const canvas = document.getElementById('artCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 380;
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#666';
            for (let i = 0; i < totalPinsInCircle; i++) {
                const angle = (i / totalPinsInCircle) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = currentThickness;
            ctx.globalAlpha = 0.8;
            
            for (let i = 0; i < pinSequence.length - 1; i++) {
                const pin1 = pinSequence[i];
                const pin2 = pinSequence[i + 1];
                
                const angle1 = (pin1 / totalPinsInCircle) * 2 * Math.PI;
                const angle2 = (pin2 / totalPinsInCircle) * 2 * Math.PI;
                
                const x1 = centerX + radius * Math.cos(angle1);
                const y1 = centerY + radius * Math.sin(angle1);
                const x2 = centerX + radius * Math.cos(angle2);
                const y2 = centerY + radius * Math.sin(angle2);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        function convertImage() {
            const fileInput = document.getElementById('imageUpload');
            const numPins = parseInt(document.getElementById('numPins').value);
            const numLines = parseInt(document.getElementById('numLines').value);
            const thickness = parseFloat(document.getElementById('lineThickness').value);
            
            if (!fileInput.files[0]) {
                alert('Please select an image first');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    generateStringArtFromImage(img, numPins, numLines, thickness);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(fileInput.files[0]);
        }
        
        function generateStringArtFromImage(img, numPins, numLines, thickness) {
            const canvas = document.getElementById('artCanvas');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 380;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            const size = Math.min(img.width, img.height);
            const scale = (radius * 2) / size;
            const drawSize = size * scale;
            
            // Fill with white background
            tempCtx.fillStyle = '#fff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw image centered and scaled
            tempCtx.drawImage(img, 
                (img.width - size) / 2, (img.height - size) / 2, size, size,
                centerX - drawSize/2, centerY - drawSize/2, drawSize, drawSize
            );
            
            // Convert to grayscale and enhance contrast
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Convert to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            
            // Apply contrast enhancement and circular mask
            for (let i = 0; i < data.length; i += 4) {
                const x = (i / 4) % tempCanvas.width;
                const y = Math.floor((i / 4) / tempCanvas.width);
                
                // Check if pixel is within the circle
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius) {
                    // Enhance contrast using sigmoid function
                    let gray = data[i];
                    gray = gray / 255; // Normalize to 0-1
                    gray = 1 / (1 + Math.exp(-12 * (gray - 0.5))); // Sigmoid contrast
                    gray = Math.round(gray * 255); // Back to 0-255
                    
                    data[i] = data[i + 1] = data[i + 2] = gray;
                } else {
                    // Outside circle - make white
                    data[i] = data[i + 1] = data[i + 2] = 255;
                }
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            
            console.log('Starting string art generation...');
            const sequence = generateSequenceFromImage(tempCtx, numPins, numLines, radius, centerX, centerY);
            console.log('Generated sequence with', sequence.length, 'pins');
            
            pinSequence = sequence;
            totalPinsInCircle = numPins;
            currentIndex = 0;
            document.getElementById('totalPins').textContent = sequence.length;
            document.getElementById('pinSequence').value = sequence.join(', ');
            updateDisplay();
            
            drawStringArt(sequence, numPins, currentThickness);
        }
        
        function generateSequenceFromImage(ctx, numPins, numLines, radius, centerX, centerY) {
            const sequence = [0];
            let currentPin = 0;
            const usedPins = new Array(numPins).fill(0);
            
            // Create a working copy of the image data
            const workingImageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
            const workingData = new Uint8ClampedArray(workingImageData.data);
            
            for (let line = 0; line < numLines - 1; line++) {
                let bestPin = -1;
                let bestScore = -1;
                
                for (let pin = 0; pin < numPins; pin++) {
                    if (pin === currentPin) continue;
                    
                    // Penalize recently used pins
                    const recentUsePenalty = Math.max(0, 50 - (line - usedPins[pin]));
                    
                    const score = calculateLineScore(workingData, ctx.canvas.width, ctx.canvas.height, 
                                                   currentPin, pin, numPins, radius, centerX, centerY) - recentUsePenalty;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestPin = pin;
                    }
                }
                
                if (bestPin !== -1) {
                    sequence.push(bestPin);
                    
                    // Simulate drawing the line by darkening pixels
                    drawLineOnImageData(workingData, ctx.canvas.width, ctx.canvas.height,
                                      currentPin, bestPin, numPins, radius, centerX, centerY);
                    
                    usedPins[bestPin] = line;
                    currentPin = bestPin;
                }
            }
            
            return sequence;
        }
        
        function calculateLineScore(imageData, width, height, pin1, pin2, numPins, radius, centerX, centerY) {
            const angle1 = (pin1 / numPins) * 2 * Math.PI;
            const angle2 = (pin2 / numPins) * 2 * Math.PI;
            
            const x1 = centerX + radius * Math.cos(angle1);
            const y1 = centerY + radius * Math.sin(angle1);
            const x2 = centerX + radius * Math.cos(angle2);
            const y2 = centerY + radius * Math.sin(angle2);
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.max(1, Math.floor(length));
            
            let score = 0;
            let validPixels = 0;
            
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(x1 + (dx * i) / steps);
                const y = Math.round(y1 + (dy * i) / steps);
                
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const pixelIndex = (y * width + x) * 4;
                    const darkness = 255 - imageData[pixelIndex]; // Higher score for darker pixels
                    score += darkness;
                    validPixels++;
                }
            }
            
            return validPixels > 0 ? score / validPixels : 0;
        }
        
        function drawLineOnImageData(imageData, width, height, pin1, pin2, numPins, radius, centerX, centerY) {
            const angle1 = (pin1 / numPins) * 2 * Math.PI;
            const angle2 = (pin2 / numPins) * 2 * Math.PI;
            
            const x1 = centerX + radius * Math.cos(angle1);
            const y1 = centerY + radius * Math.sin(angle1);
            const x2 = centerX + radius * Math.cos(angle2);
            const y2 = centerY + radius * Math.sin(angle2);
            
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.max(1, Math.floor(length));
            
            // Lighten pixels along the line to simulate string coverage
            const lineOpacity = 0.15; // How much each line lightens the image
            
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(x1 + (dx * i) / steps);
                const y = Math.round(y1 + (dy * i) / steps);
                
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const pixelIndex = (y * width + x) * 4;
                    
                    // Lighten the pixel (simulate string covering dark areas)
                    const currentValue = imageData[pixelIndex];
                    const newValue = Math.min(255, currentValue + (255 - currentValue) * lineOpacity);
                    
                    imageData[pixelIndex] = newValue;     // R
                    imageData[pixelIndex + 1] = newValue; // G
                    imageData[pixelIndex + 2] = newValue; // B
                }
            }
        }
        
        function drawStringArt(sequence, numPins, thickness) {
            const canvas = document.getElementById('artCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 380;
            
            ctx.fillStyle = currentColors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = currentColors.pin;
            for (let i = 0; i < numPins; i++) {
                const angle = (i / numPins) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            ctx.strokeStyle = currentColors.line;
            ctx.lineWidth = thickness || currentThickness;
            ctx.globalAlpha = 0.8;
            
            for (let i = 0; i < sequence.length - 1; i++) {
                const pin1 = sequence[i];
                const pin2 = sequence[i + 1];
                
                const angle1 = (pin1 / numPins) * 2 * Math.PI;
                const angle2 = (pin2 / numPins) * 2 * Math.PI;
                
                const x1 = centerX + radius * Math.cos(angle1);
                const y1 = centerY + radius * Math.sin(angle1);
                const x2 = centerX + radius * Math.cos(angle2);
                const y2 = centerY + radius * Math.sin(angle2);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // Initialize with default sequence
        document.getElementById('pinSequence').value = '0, 199, 97, 86, 175, 64, 153, 42, 131, 20, 109, 187, 76, 165, 54, 143, 32, 121, 10, 99';
        
        // Auto-load the default sequence on page load
        window.addEventListener('load', function() {
            setTimeout(() => {
                loadSequence();
            }, 100);
        });
    </script>
</body>
</html>
